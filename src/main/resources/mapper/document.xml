<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zero.system.mapper.UserMapper">

    <select id="queryUserList" resultType="com.zero.system.vo.UserVo">
        select t.* from t_user t where 1=1
        <if test="userVo.name != null and userVo.name != ''">
            and t.name = #{userVo.name}
        </if>
        <if test="userVo.deleted != null and userVo.deleted != ''">
            and t.deleted = #{userVo.name}
        </if>
        order by t.create_time desc
    </select>

<!--    查首冲
    select r.user_id,amount,r.create_time from red_fund_in_out r
    LEFT JOIN (SELECT rio.user_id id,min(rio.create_time) create_time FROM red_fund_in_out rio GROUP BY rio.user_id) k
    on r.user_id=k.id
    WHERE
    r.create_time=k.create_time
    GROUP BY r.user_id-->

<!--    查二充
    select t.user_id,t.create_time,t.amount from red_fund_in_out t where t.user_id = '1212214581523996674' order by t.create_time limit 1 offset 1-->

<!--    N张主从表查询
    SELECT  rg.group_name,rg.room,rg.group_type,rg.admin_id,rg.create_time,rg.kill_rate,rg.shut_up,rg.status,count(g.user_id)num from
    red_group rg left join red_group_users g on rg.id = g.group_id left join red_user u on g.user_id = u.id
    where rg.deleted = 0 and g.deleted = 0 and u.deleted = 0 and u.user_type = 1 GROUP BY g.group_id;-->

<!--    判断时间重叠-->
    <select id="test">
        <if test="activity.startTime !=null and activity.startTime !=''"> <!-- 有开始时间-->
            <if test=" activity.endTime != null and activity.endTime != ''"> <!-- 开始时间结束时间都有的情况 ， 1、活动开始在这区间 2、活动的结束时间在这区间 (注：由于长期活动只有开始时间所以包含在内)-->
                <![CDATA[ and (
            (date_format( #{activity.startTime}, '%Y-%m-%d') BETWEEN date_format( k.start_time, '%Y-%m-%d') and k.end_time and k.is_permanent <> 1) or
            (date_format( #{activity.endTime}, '%Y-%m-%d') BETWEEN date_format( k.start_time, '%Y-%m-%d') AND k.end_time and k.is_permanent <>1) or
            (date_format( k.start_time, '%Y-%m-%d') >= date_format( #{activity.startTime}, '%Y-%m-%d') and  date_format(k.end_time, '%Y-%m-%d') <= date_format( #{activity.endTime}, '%Y-%m-%d') and k.is_permanent <>1) or
            (#{activity.endTime}>= k.start_time  and k.is_permanent =1)
            ) ]]>
            </if>
            <if test=" activity.endTime == null or activity.endTime == ''">  <!-- 有开始时间，无结束时间 1、活动的结束时间大于等于传入的开始时间 2.长期有效的活动-->
                <![CDATA[and ((#{activity.startTime} BETWEEN k.start_time and k.end_time) or  (#{activity.startTime}>= k.start_time and k.is_permanent =1))]]>
            </if>
        </if>

        <if test="activity.startTime == null or activity.startTime == ''"> <!-- 无开始时间 -->
            <if test="activity.endTime !=null and activity.endTime !=''"> <!-- 有结束时间 只需要活动的结束时间大于等于传入的结束时间或者长期有效活动-->
                <![CDATA[ and ((#{activity.endTime} between k.start_time and k.end_time and k.is_permanent <>1 ) or (#{activity.endTime}>= k.start_time  and k.is_permanent =1)) ]]>
            </if>
        </if>

        ORDER BY
        k.update_time DESC
    </select>

<!--    <if test="account.status !=null and account.status !=''">
        <choose>
            <when test='account.status.contains(",")'>
                and r.status in
                <foreach item="item" index="index" collection="account.status.split(',')" open="(" separator="," close=")">
                    #{item}
                </foreach>
            </when>
            <otherwise>
                and r.status =  #{account.status}
            </otherwise>
        </choose>
    </if>-->



    <!--&#45;&#45; 首充
    1236138972413652994  2020-03-10 10:12:52  11
    1236138972413652994  2020-03-11 09:43:14  1000

    select f.create_time,o.amount from red_fund_in_out o,(
    select min(t.create_time)create_time from red_fund_in_out t where t.user_id = '1236912296454389761'
    GROUP BY date_format(t.create_time, '%Y-%m-%d')
    ) f  where f.create_time = o.create_time GROUP BY f.create_time

    &#45;&#45; 二充
    1236138972413652994  2020-03-10 10:25:32  10
    1236138972413652994  2020-03-11 09:44:29  300
    select m.create_time,k.amount from (
    select min(o.create_time)create_time from red_fund_in_out o where o.user_id = '1236912296454389761' and o.create_time not in
    (select min(t.create_time)create_time from red_fund_in_out t where t.user_id = '1236912296454389761' GROUP BY date_format(t.create_time, '%Y-%m-%d'))
    GROUP BY date_format(o.create_time, '%Y-%m-%d')
    ) m, red_fund_in_out k where m.create_time = k.create_time and k.user_id = '1236912296454389761' GROUP BY m.create_time
-->


    <!-- 用户首充-->
    <select id="userFirstCharge" resultType="java.lang.Double">
        select coalesce(sum(o.amount),0) from red_fund_in_out o,(
        select min(t.create_time)create_time,t.user_id from red_fund_in_out t where t.user_id in
        <foreach item="item" collection="list" open="(" separator="," close=")">
            #{item}
        </foreach>
        and t.fund_type in(1,3,5) and t.status = 6 and t.create_time between #{startTime} and #{endTime}
        group by date_format(t.create_time, '%Y-%m-%d'),t.user_id
        )f where f.create_time = o.create_time and o.user_id = f.user_id
    </select>


    <!-- 用户二充-->
    <select id="userSecondCharge" resultType="java.lang.Double">
        select coalesce(sum(k.amount),0) from (
        select min(o.create_time)create_time,o.user_id from red_fund_in_out o where o.user_id in
        <foreach item="item" collection="list" open="(" separator="," close=")">
            #{item}
        </foreach>
        and o.create_time not in(
        select min(t.create_time)create_time from red_fund_in_out t where t.user_id in
        <foreach item="item" collection="list" open="(" separator="," close=")">
            #{item}
        </foreach>
        and t.fund_type in(1,3,5) and t.status = 6 and t.create_time between #{startTime} and #{endTime}
        group by date_format(t.create_time, '%Y-%m-%d'),t.user_id
        )
        and o.fund_type in(1,3,5) and o.status = 6 and o.create_time between #{startTime} and #{endTime}
        group by date_format(o.create_time, '%Y-%m-%d'),o.user_id
        )m, red_fund_in_out k where m.create_time = k.create_time and m.user_id=k.user_id
    </select>




</mapper>